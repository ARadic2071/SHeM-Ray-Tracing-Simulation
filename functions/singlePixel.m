% Copyright (c) 2018, Sam Lambrick.
% All rights reserved.
% This file is part of the SHeM Ray Tracing Simulation, subject to the 
% GNU/GPL-3.0-or-later.

function simulationData = singlePixel(sample_surface, ray_pos, ray_dir, ...
    maxScatter, thePath, save_to_text, pinhole_surface, effuse_dir, ...
    effuse_pos, make_sphere, dist_to_sample, sphere_r, diffuse)
% singlePixel.m
%
% INPUTS:
%  sample_surface  - A TriagSurface object containing the triangulated mesh
%                    surface of the sample
%  ray_pos         - A nx3 array of initial ray positions usually generated by
%                    the function create_strating_rays.m 
%  ray_dir         - A nx3 array of initial ray directions usually generated by
%                    the function create_strating_rays.m
%  maxScatter      - The maximum number of sample scatters a single ray is
%                    allowed to undergo
%  thePath         - String, the directory for the simulation e.g.
%                    'simulations/001_example'
%  save_to_text    - Boolean, should data about the single pixel scan be 
%                    saved to a text file for plotting using other software
%  pinhole_surface - A TriagSurface object containing the pinhole plate
%  effuse_dir      - A 3xn array of initial ray directions for the effuse beam 
%  effuse_pos      - A 3xn array of intial ray positions for the effuse beam
%  make_sphere     - 0/1, should an analytic sphere be included
%  dist_to_sample  - The distance between the pinhole plate and the sample, used
%                    when an analytic sphere is modelled
%  sphere_r        - Radius of the analytic sphere (mm)
%  diffuse         - The scattering off of the sample, [0,1] or 2, used when an
%                    analytic sphere is present.
%
% OUTPUTS:
%  simulationData - a SinglePixelInfor object contating infromation about the
%                   simulation that has been run
    
    % Dependent variables inside this function
    n_rays = length(ray_pos);
    n_effuse = length(effuse_pos);
    
    % Estimation of the time the simulation will take
    time_estimate(n_rays, n_effuse, sample_surface, 1);
    
    tic
    
    % The main beam rays
    [cntr, killed, left, final_pos, final_dir, numScattersRayDetect, ~] = ...
        trace_rays(ray_pos, ray_dir, sample_surface, maxScatter, ...
                   pinhole_surface, 0, 0, make_sphere, dist_to_sample, ...
                   sphere_r, diffuse);
    
    % The effusive beam rays
    if size(effuse_pos, 1) == 0
        % If the effusive beam is not being modelled
        effuseCnt = 0;
        effuseKilled = 0;
        effuseLeft = 0;
    else
        % The effusive beam is being modelled
        [effuseCnt, effuseKilled, effuseLeft, ~, ~, ~, ~] = ...
            trace_rays(effuse_pos, effuse_dir, sample_surface, maxScatter, ...
                       pinhole_surface, 0, 0, make_sphere, dist_to_sample, ...
                       sphere_r, diffuse);
    end
      
    t = toc;
    
    % Generate the results object
    simulationData = SinglePixelInfo(cntr, killed, left, numScattersRayDetect, ...
        final_pos, final_dir, t, effuseCnt, effuseKilled, effuseLeft);
    
    % The actual time the simulation took
    fprintf('Actual time taken: %f s\n', t);
    hr = floor(t/(60^2));
    min = floor((t - hr*60*60)/60);
    if min == 60
        hr = hr + 1;
        min = 0;
    end
    fprintf('Which is: %i hr %2i mins\n\n', hr, min);
    
    if save_to_text
        % Save the final positions and directions to a text file.
        simulationData.saveDirectionPositions([thePath ...
            '/positionsDirections.csv']);
    end
end

