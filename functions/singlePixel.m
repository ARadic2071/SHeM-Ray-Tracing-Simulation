% singlePixel.m
%
% Copyright (c) 2018-19, Sam Lambrick.
% All rights reserved.
% This file is part of the SHeM Ray Tracing Simulation, subject to the 
% GNU/GPL-3.0-or-later.
%
% INPUTS:
%  sample_surface  - A TriagSurface object containing the triangulated mesh
%                    surface of the sample
%  ray_pos         - A nx3 array of initial ray positions usually generated by
%                    the function create_strating_rays.m 
%  ray_dir         - A nx3 array of initial ray directions usually generated by
%                    the function create_strating_rays.m
%  maxScatter      - The maximum number of sample scatters a single ray is
%                    allowed to undergo
%  thePath         - String, the directory for the simulation e.g.
%                    'simulations/001_example'
%  save_to_text    - Boolean, should data about the single pixel scan be 
%                    saved to a text file for plotting using other software
%  pinhole_surface - A TriagSurface object containing the pinhole plate
%  effuse_dir      - A 3xn array of initial ray directions for the effuse beam 
%  effuse_pos      - A 3xn array of intial ray positions for the effuse beam
%  make_sphere     - 0/1, should an analytic sphere be included
%  dist_to_sample  - The distance between the pinhole plate and the sample, used
%                    when an analytic sphere is modelled
%  sphere_r        - Radius of the analytic sphere (mm)
%  diffuse         - The scattering off of the sample, [0,1] or 2, used when an
%                    analytic sphere is present.
%  plate_model     - string, the model used to represent the pinhole plate,
%                    'stl', 'circle', 'aperture'
%  thePlate        - list containing information about the modelling of the
%                    pinhole plate: [circle_plate_r, aperture_axis_1, 
%                    aperture_axis_2, aperture_c];
%  apertureAbstract- list containing information on the modelling of
%                    abstract detection: [aperture_theta, aperture_phi, 
%                    aperture_half_cone].
%
% OUTPUTS:
%  simulationData - a SinglePixelInfor object contating infromation about the
%                   simulation that has been run
function simulationData = singlePixel(sample_surface, ray_pos, ray_dir, ...
    maxScatter, thePath, save_to_text, pinhole_surface, effuse_dir, ...
    effuse_pos, make_sphere, dist_to_sample, sphere_r, diffuse, ...
    plate_model, thePlate, apertureAbstract)
    
    % Dependent variables inside this function
    n_rays = length(ray_pos);
    n_effuse = length(effuse_pos);
    if strcmp(plate_model, 'aperture')
        plate_represent = 0;
    elseif strcmp(plate_model, 'abstract')
        plate_represent = 3;
    elseif strcmp(plate_model, 'stl')
        plate_represent = 2;
    else
        plate_represent = 1;
    end
    
    % Estimation of the time the simulation will take
    time_estimate(n_rays, n_effuse, sample_surface, 1, 'stl');
    
    tic
    
    % The main beam rays
    if plate_represent == 2
        % We represent the pinhole plate as a CAD model with a triangulated
        % mesh
        [cntr, killed, left, final_pos, final_dir, numScattersRayDetect, ~] = ...
            trace_rays(ray_pos, ray_dir, sample_surface, maxScatter, ...
                       pinhole_surface, 0, 0, make_sphere, dist_to_sample, ...
                       sphere_r, diffuse);
    elseif plate_represent == 3
        % We are representing the pinhole plate as abstract detector apertures
        % on a hemisphere.
        [cntr, killed, left, final_pos, final_dir, numScattersRayDetect, ~] = ...
            traceAbstractPlate(ray_pos, ray_dir, sample_surface, maxScatter, ...
                               0, 0, make_sphere, ...
                               dist_to_sample, sphere_r, diffuse, ...
                               apertureAbstract);
    else
        % We are representing the pinhole plate as either a circle with an
        % aperture or just an aperture
        [cntr, killed, left, final_pos, final_dir, numScattersRayDetect, ~] = ...
            traceSimplePlate(ray_pos, ray_dir, sample_surface, ...
                             maxScatter, 0, 0, ...
                             make_sphere, dist_to_sample, sphere_r, ...
                             diffuse, plate_represent, thePlate);
    end
    
    % The effusive beam rays
    if size(effuse_pos, 1) == 0
        % If the effusive beam is not being modelled
        effuseCnt = 0;
        effuseKilled = 0;
        effuseLeft = 0;
    else
        % The effusive beam is being modelled
        if plate_represent == 2
            % We represent the pinhole plate as a CAD model with a triangulated
            % mesh
            [effuseCnt, effuseKilled, effuseLeft, ~, ~, ~, ~] = ...
                trace_rays(effuse_pos, effuse_dir, sample_surface, maxScatter, ...
                           pinhole_surface, 0, 0, make_sphere, dist_to_sample, ...
                           sphere_r, diffuse);
        elseif plate_represent == 3
            % We are representing the pinhole plate as abstract detector apertures
            % on a hemisphere.
            [effuseCnt, effuseKilled, effuseLeft, ~, ~, ~, ~] = ...
                traceAbstractPlate(effuse_pos, effuse_dir, sample_surface, maxScatter, ...
                                   0, 0, make_sphere, ...
                                   dist_to_sample, sphere_r, diffuse, ...
                                   apertureAbstract);
    else
            % We are representing the pinhole plate as either a circle with an
            % aperture or just an aperture
            [effuseCnt, effuseKilled, effuseLeft, ~, ~, ~, ~] = ...
                traceSimplePlate(effuse_pos, effuse_dir, sample_surface, ...
                                 maxScatter, 0, 0, ...
                                 make_sphere, dist_to_sample, sphere_r, ...
                                 diffuse, plate_represent, thePlate); 
        end
    end
      
    t = toc;
    
    % Generate the results object
    simulationData = SinglePixelInfo(cntr, killed, left, numScattersRayDetect, ...
        final_pos, final_dir, t, effuseCnt, effuseKilled, effuseLeft);
    
    % The actual time the simulation took
    fprintf('Actual time taken: %f s\n', t);
    hr = floor(t/(60^2));
    min = floor((t - hr*60*60)/60);
    if min == 60
        hr = hr + 1;
        min = 0;
    end
    fprintf('Which is: %i hr %2i mins\n\n', hr, min);
    
    if save_to_text
        % Save the final positions and directions to a text file.
        simulationData.saveDirectionPositions([thePath ...
            '/positionsDirections.csv']);
    end
end

