% Copyright (c) 2018, Sam Lambrick.
% All rights reserved.
% This file is part of the SHeM Ray Tracing Simulation, subject to the 
% GNU/GPL-3.0-or-later.

function line_scan_info = lineScan(sample_surface, scan_range, ray_pos, ...
    ray_dir, raster_movement, maxScatter, thePath, Direction, Save_text, ...
    pinhole_surface, effuse_dir, effuse_pos, make_sphere, dist_to_sample, ...
    sphere_r, diffuse)
% lineScan.m
%
% INPUTS:
%  sample_surface  - A TriagSurface object that contains a description of the
%                    sample
%  scan_range      - A two element vector containing the range of positions
%                    between which the scan is to be taken [low, high] in mm
%  ray_pos         - A nx3 array of initial ray positions usually generated by
%                    the function create_strating_rays.m 
%  ray_dir         - A nx3 array of initial ray directions usually generated by
%                    the function create_strating_rays.m
%  raster_movment  - The raster movment (in mm) betwen pixels
%  maxScatter      - The maximum number of scatters a single ray is allowed
%                    to undergo
%  thePath         - String, the directory for the simulation 
%                    e.g. 'simulations/01'
%  Direction       - A character determining which direction to do the scan can
%                    be 'x', 'y' or 'z'. If 'y' then the sample is moved
%                    diagonally away from the pinhole plate to keep the
%                    same region of sample under investigation.
%  Save_text       - Boolean, should data about the line scan be saved to a text
%                    file for plotting using other software
%  pinhole_surface - A Triag surface object containing the triangulation of the 
%  effuse_dir      - A 3xn array of initial ray directions for the effuse beam 
%  effuse_pos      - A 3xn array of initial ray positions for the effuse beam
%  make_sphere     - 1/0, should the analytic sphere be included
%  dist_to_sample  - The sampl-pinhole plate distance, for use when the sphere
%                    is included
%  sphere_r        - The radius of the analytic sphere
%  diffuse         - The scattering off of the sphere, [0,1] or 2
%
% OUTPUTS:
%  line_scan_info - A LineInfo object containing the information about the
%                   simulation
    
    n_rays = length(ray_pos);
    n_effuse = length(effuse_pos);
    textFname = 'data_for_plotting.csv';
    
    % Sample positions
    sample_xs = scan_range(1):raster_movement:scan_range(2);
    n_pixels = length(sample_xs);
    
    % Create variables for output data
    counters = zeros(maxScatter, n_pixels);
    num_killed = zeros(n_pixels, 1);
    cntr_effuse_single = zeros(n_pixels, 1);
    counter_effuse_multiple = zeros(n_pixels, 1);
    killed_effuse = zeros(n_pixels, 1);
    
    % Estimate of the time for the simulation
    t_estimate = time_estimate(n_rays, n_effuse, sample_surface, n_pixels);
    
    tic
    
    % Creates a parallel pool if one does not already exist
    if isempty(gcp('nocreate'))
       parpool 
    end
    
    % Generates a graphical progress bar if we are using the MATLAB GUI.
    progressBar = feature('ShowFigureWindows');
    if progressBar
        ppm = ParforProgMon('Simulation progress: ', n_pixels);
    else
        % If the variable ppm is undefined then the parfor loop will
        % throw errors.
        ppm = 0;
    end
    
    parfor i_=1:n_pixels
        scan_pos = sample_xs(i_);
        
        % Put the sample into the right place for this iteration
        switch Direction
            case 'x'
                surface = copy(sample_surface);
                surface.moveBy([scan_pos 0 0]);
            case 'y'
                surface = copy(sample_surface);
                surface.moveBy([scan_pos -scan_pos 0]);
            case 'z'
                surface = copy(sample_surface);
                surface.moveBy([0 0 scan_pos]);
            otherwise
                error('Specify a correct direction for the line scan')
        end
        
        % The direct beam rays
        [~, killed, ~, ~, ~, numScattersRayDetect, ~] = ...
            trace_rays(ray_pos, ray_dir, surface, maxScatter, ...
                       pinhole_surface, scan_pos, 0, make_sphere, ...
                       dist_to_sample, sphere_r, diffuse);
        
        % The effusive beam rays
        if size(effuse_pos, 1) == 0
            % If the effusive beam is not being modelled
            effuseKilled = 0;
            histRayEffuse = zeros(1,maxScatter);
        else
            % If the effusive beam is being modelled
            [~, effuseKilled, ~, ~, ~, numScattersRayEffuse, ~] = ...
                trace_rays(effuse_pos, effuse_dir, surface, maxScatter, ...
                           pinhole_surface, scan_pos, 0, make_sphere, ...
                           dist_to_sample, sphere_r, diffuse);
            
            histRayEffuse = binMyWay(numScattersRayEffuse, maxScatter);
        end
        
        % Need to give binMyWayMex an array of more than 1
        histRay = binMyWay(numScattersRayDetect, maxScatter);
        
        % Update the graphical progress bar if we are using the MATLAB GUI.
        if progressBar
            ppm.increment();
        end
        
        % Save the data for this iteration
        cntr_effuse_single(i_) = histRayEffuse(1);
        counter_effuse_multiple(i_) = sum(histRayEffuse(2:end));
        killed_effuse(i_) = effuseKilled;
        counters(:,i_) = histRay;
        num_killed(i_) = killed;
        
        % Delete the surface object for this iteration
        delete(surface);
    end
    
    % Close the parallel pool
    current_pool = gcp('nocreate');
    delete(current_pool);
    
    t = toc;
    
    % The actual time the simulation took
    fprintf('Actual time taken: %f s\n', t);
    hr = floor(t/(60^2));
    min = floor((t - hr*60*60)/60);
    if min == 60
        hr = hr + 1;
        min = 0;
    end
    fprintf('Which is: %i hr %2i mins\n\n', hr, min);
    
    % Generate an object to store the information
    line_scan_info = LineInfo(Direction, scan_range, counters, num_killed, ...
        raster_movement, n_rays, t, t_estimate, cntr_effuse_single, ...
        counter_effuse_multiple, killed_effuse);
    
    % Save desired outputs to text for plotting in other software
    if Save_text
        line_scan_info.saveText([thePath '/' textFname]);
    end
    
    if progressBar
        line_scan_info.producePlots(thePath);
    end
end
