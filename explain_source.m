%% Source model in ray tracing
% *Sam Lambrick*
% 
% A description of how the SHeM ray tracing simulation generates the rays from 
% a model of the source abd how to add a new source model to the simulation.

%%

addpath(genpath('functions'), 'classes', 'mexFiles');
%% Two routes to generate rays
% The ray tracing simulation is set-up to allow two methods of ray generation, 
% in the first case the parameters describing the beam source are passed into 
% the mex C code and the rays are generated then traced one by one. In the second 
% case the rays are generated by a Matlab function and the starting positions 
% and directions of all the rays are provided to the mex code in two large arrays. 
% The C method is faster and has lower memory requirements but is not easily adapted 
% to other source models. The MATLAB method is not as optimal but allows new models 
% to be inserted simply as new MATLAB functions.
% 
% In both cases parameters associated with the source are encoded in a struct 
% inside the |performScan.m| script and extracted from that struct when needed 
% - either when the |make???| scripts are called of the mex functions are called.
% MATLAB method
% Currently three functions in MATLAB create the rays for the simulation. One 
% of them |makeEffuse(...)| is designed for generating a model of the effuse beam 
% using a simple cosine model. The other two, |makeUniform(...)| and  |makeUniform(...)| 
% encodes the twomodels of the source currently implemented and can be used as 
% an example of a source generating function.
% 
% The functions require general arguments: * The number of rays to generate 
% * The centre of the pinhole * The radius of the pinhole * The incidence angle 
% along with a parameter specific to the model being used. The function returns 
% two matrices of positions and directions of the rays. The direction of the beam 
% is always within the _(x,y)_ plane of the simulation (which is the _(x,z)_ plane 
% within how we normally refer to the microscope) so only one angle is needed 
% to define the direction of the beam. The functions uses name value pairs to 
% accept arguments.

% For example to generate rays according to the uniform model of the source:
pinhole_c = [-2.1, 0, 0];
pinhole_r = 0.001;
theta_max = atan(0.1/100);
init_angle = 45;
[ray_pos, ray_dir] = makeUniform('n_rays', 5, 'pinhole_c', pinhole_c, 'pinhole_r', ...
    pinhole_r, 'theta_max', theta_max, 'init_angle', init_angle);
%% 
% If we examine the outputs we find random positions in the pinhole and directions 
% along the beam with some slight variations:

disp(ray_pos)
disp(ray_dir)
% C method
% Alternatively the ray position and directions may be generated directly in 
% the C code. In this mode the parameters are passed through into the mex function 
% and the directions and positions generated there for each ray just before that 
% ray is traced - rather than all initial positions and directions being generated 
% at the beginning before the first ray is traced. This means that is is not possible 
% to record the starting positions and directions of the rays using the C method.
% 
% The Uniform and Gaussian models of the source are encoded in the C code, and 
% while in principle a new function could be written and added there the passing 
% of new arguments through to it is much more involved so wouldn't be recommended 
% unless the new source model is intended to be the new default.
%% Uniform model
% The uniform model assumes a uniformly emitting skimmer as the microscope source. 
% The result of such an assumption is a linear probability distribution of polar 
% angles (parallel to the beam) for the atoms/rays emerging from the pinhole.
% 
% 
% 
% At an angle $\theta$ from the centre of the skimmer aperture there is a annulus 
% of length $2\pi\tan\theta$ emitting helium towards the pinhole which can be 
% simplified to $\propto\theta$ using the small angle formula. If we assume the 
% skimmer is emitting uniformly across its whole area and there is negligible 
% variation in the directional intensity coming out the skimmer then the directions 
% of the atoms at the pinhole have a probability distribution $\propto\theta$, 
% which we can use to generate the initial directions of the rays:
% 
% $P(\theta) = \frac{2\theta}{\theta_\mathrm{max}^2}$.

thetas = linspace(0, theta_max, 1000);
Ps = 2*tan(thetas)/theta_max^2;
figure
plot(thetas, Ps)
xlabel('\theta/rad')
ylabel('P(\theta)')
grid on
%% Gaussian model
% The Gaussian model assumes a 2D Gaussian model of the virtual source, and 
% a pinhole much smaller than the source size. The parameter specified is the 
% standard deviation of the Gaussian source in radians.
% 
% 
% 
% The resulting probability distribution of polar angles (again using the small 
% angle approximation) in the pinhole is:
% 
% $P(\theta) = \frac{1}{\sigma^2}\theta\,\textrm{e}^{\,-\theta^2/2\sigma^2}$.

sigma_source = 0.01;
thetas2 = linspace(0, sigma_source*4, 1000);
Ps2 = 1/(sigma_source^2)*thetas2.*exp(-thetas2.^2/(2*sigma_source^2));
figure
plot(thetas2, Ps2)
xlabel('\theta/rad')
ylabel('P(\theta)')
grid on
%% 
% In order to sample from this distribution the CDF must be found:
% 
% $$CDF(\theta) = \int_0^\theta\frac{1}{\sigma^2}\theta\prime\,\textrm{e}^{-\frac{\theta\prime^{2}}{2\sigma^2}}\,\textrm{d}\theta\prime$$
% 
% $$CDF(\theta) = 1 - \mathrm{e}^{-\frac{\theta^2}{2\sigma^2}}$$
% 
% In order to sample from the distribition a uniform random number, X, in the 
% range [0,1] is generated then the CDF is inverted.
% 
% $$\theta = \sigma\sqrt{-2\ln\frac{1 - X}{1}}$$

X = rand(1e5, 1);
B = 1/(1-exp(-pi^2/(2*sigma_source^2)));
theta_rand = sigma_source*sqrt(-2*log((B-rand(n_rays,1))/B));;
figure;
histogram(theta_rand, 'Normalization', 'pdf')
xlabel('\theta/rad')
ylabel('P(\theta)')
xlim([0, 0.04])
grid on
%% Writing a new source function
% If one is capable of writing some MATLAB code that generates the starting 
% positions and directions of rays according to some new model of the source then 
% it is reasonably straightforward to add that model to the simulation. 
%% 
% # Write down the model in the form of a probability density function for the 
% directions of atoms at the pinhole along with the shape of that pinhole.
% # Work out which parameters are needed for the model and add those to the 
% |direct_beam| struct in the |performScan.m| script.
% # In the |switch_plate.m| fucntion add an extra case to the |switch| statement 
% for your new source model. This is only necessary in the part of the function 
% that deals with the 'MATLAB' |ray_model.|
% # Write a function that takes the required parameters and returns |[ray_pos, 
% ray_dir]| in the same manner as the example given above.
%% 
% The new source function should be called |makeModel| to keep with the existing 
% functions and take it's arguments as name value pairs using varargin. Use the 
% existing functions as templates, in particular the code that translates the 
% rays to the pinhole and rotates the directions to match the incidence angle 
% will likely not change.
% 
% Below is a template of a new source function. The code to be changed is between 
% the two highlighted lines. If a single pinhole is still being used then the 
% position generation code can stay the same, if not that can be adapted with 
% any appropriate parameters replacing |pinhole_r| (the centre of the aperture 
% pattern will still be needed). Replace the |generate_theta| function with code 
% that generates the appropriate polar angles for the starting directions for 
% the rays, an alternative method (i.e. non-uniform) method for the azimuthal 
% angle can also be introduced. The function file should be saved in the 'functions/source_functions' 
% directory.
%%
% 
%   % Documentation...
%   function [ray_pos, ray_dir] = makeTemplate(varargin)
%       
%       for i_=1:2:length(varargin)
%           switch varargin{i_}
%               case 'n_rays'
%                   n_rays = varargin{i_+1};
%               case 'pinhole_c'
%                   pinhole_c = varargin{i_+1};
%               case 'pinhole_r'
%                   pinhole_r = varargin{i_+1};
%               case 'plot_starting'
%                   plot_starting_positions = varargin{i_+1};
%               case 'thePath'
%                   thePath = varargin{i_+1};
%               case 'parameter'
%                   parameter = varargin{i_+1};
%               case 'init_angle'
%                   init_angle = varargin{i_+1};
%               otherwise
%                   warning([' Input ' num2str(i_) ' not recognised.'])
%           end
%       end
%       
%       % Default inputs
%       if ~exist('plot_starting_positions', 'var')
%           plot_starting_positions = false;
%       end
%       
%       % Perform input checking
%       if ~exist('ThePath', 'var') && plot_starting_positions
%           error('Cant plot starting positions if no data path provided');
%       end
%       
%   
%   %----------------------------------------------------------------------------%
%       % Generate the positions of the rays that you want
%       pos_phi = 2*pi*rand(n_rays,1);
%       pos_r = pinhole_r*sqrt(rand(n_rays,1));
%       ray_pos2(:,1) = pos_r .* cos(pos_phi);
%       ray_pos2(:,3) = pos_r .* sin(pos_phi);
%       ray_pos2(:,2) = zeros(n_rays,1);
%       
%       % Generate the (theta,phi) direction of the rays that you want
%       dir_theta = generate_theta(parameter);
%       dir_phi = 2*pi*rand(n_rays,1);
%   %----------------------------------------------------------------------------%
%      
%       % Generate the directions
%       ray_dir2 = [cos(dir_theta), sin(dir_theta).*cos(dir_phi), ...
%           sin(dir_theta).*sin(dir_phi)];
%       
%       % Project the ray positions into a the coordinate basis being used for the
%       % simulation
%       ray_pos = bsxfun(@plus, ray_pos2, pinhole_c);
%       
%       init_angle = (90 - init_angle)*pi/180;
%       ray_dir(:,1) = cos(-init_angle)*ray_dir2(:,1) - sin(-init_angle)*ray_dir2(:,2);
%       ray_dir(:,2) = sin(-init_angle)*ray_dir2(:,1) + cos(-init_angle)*ray_dir2(:,2);
%       ray_dir(:,3) = ray_dir2(:,3);
%       
%       % We can plot the starting positions of the rays if we want
%       if plot_starting_positions
%           plot_ray_positions(ray_pos, thePath)
%       end
%   end
%   
%   
%
%% 
% 
% 
%